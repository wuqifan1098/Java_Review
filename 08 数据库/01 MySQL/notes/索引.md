# 面试题

## 1.主键、外键和索引的区别？（华为）

|        | 主键                                           | 外键                                                     | 索引                               |
| ------ | ---------------------------------------------- | -------------------------------------------------------- | ---------------------------------- |
| 定义： | **唯一标识一条记录，不能有重复的，不允许为空** | **表的外键是另一表的主键, 外键可以有重复的, 可以是空值** | 该字段没有重复值，但可以有一个空值 |
| 作用： | 用来保证数据完整性                             | 用来和其他表建立联系用的                                 | 是提高查询排序的速度               |
| 个数： | 主键只能有一个                                 | 一个表可以有多个惟一索引                                 | 一个表可以有多个惟一索引           |

## 2.建立索引的原则 （华数）

- 为经常需要**排序，分组和联合操作**的字段建立索引
- 为常作为**查询条件的字段建**立索引
- 限制**索引的数目**
- 选择**唯一性索引**
- 尽量使用前缀的索引
- 最左前缀索引

不应建立索引的列

第一，对于那些**在查询中很少使用或者参考的列不应该创建索引**。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些**只有很少数据值的列也不应该增加索引**。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，**当修改性能远远大于检索性能时，不应该创建索引。**这是因为，**修改性能和检索性能是互相矛盾的**。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

根据数据库的功能，可以在[数据库设计](http://www.2cto.com/database/)器中创建三种索引：**唯一索引、主键索引和聚集索引**。

## 3. 联合索引和单列索引的区别（涂鸦智能）



## 4.聚集索引和非聚集索引

InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而**聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。**聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。

聚集索引的好处之一：**它对主键的排序查找和范围查找速度非常快**，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录

聚集索引的好处之二：范围查询（range query），**即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可**

表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。

叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据

https://www.jb51.net/article/140749.htm

https://cloud.tencent.com/developer/article/1125452

## 5. 说说什么是索引（阿里）

一种数据结构，能够帮助我们快速的检索数据库中的数据。

## 6. 索引采用哪种数据结构（阿里）

常见的两种数据结构B+ Tree索引 和 Hash索引。

## 7. 为什么InnoDB使用B+树的索引模型，为什么采用B+树，和Hash索引比有什么优缺点（阿里）

Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是**完全没有任何顺序**关系的，所以，对于区间查询是无法直接通过索引查询的，就**需要全表扫描**。**所以，哈希索引只适用于等值查询的场景。**而B+ 树是一种**多路平衡查询树**，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描

哈希索引适合**等值查询**，但是**无法进行范围查询** 

哈希索引没办法**利用索引完成排序** 

哈希索引不支持**多列联合索引的最左匹配规则** 

如果有大量重复键值的情况下，哈希索引的效率会很低，因为**存在哈希碰撞问题**

## 8. **在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？** （阿里）

最左前缀原则，把识别度最高的字段放到最前面。

## 9. SQL语句有没有使用索引查询统计过吗，有什么手段知道有没有走索引查询？（阿里）

通过explain查看sql语句的优化计划，通过执行计划来分析索引使用情况。

## 10. 索引什么时候会失效（cvte）

1. 如果**条件中有or**，即使其中有条件带索引也不会使用(**这也是为什么尽量少用or的原因**)
2. 对于**多列索引，不是使用的第一部分，则不会使用索引**
3. **like查询是以%开头**，以什么为结尾的模糊查询
4. 如果**列类型是字符串，那一定要在条件中将数据使用引号引用起来**,否则不使用索引
5. 如果mysql估计**使用全表扫描要比使用索引快,**则不使用索引

## 11. a，b，c三列，建立a,b,c联合索引，只使用a,b能命中索引吗（字节）

根据查询字段的位置不同来决定，**如查询a,     a,b    a,b,c    a,c   都可以走索引的，其他条件的查询不能走索引。**

组合索引 **有“最左前缀”原则**。就是只从最左面的开始组合，并不是所有只要含有这三列存在的字段的查询都会用到该组合索引。

https://www.cnblogs.com/guopengxia0719/p/10482539.html

## 12. 什么时候不适用索引

（1）**表记录太少**；

（2）**数据重复且分布平均的字段**（只有很少数据值的列）；

（3）**经常插入、删除、修改的表要减少索引**；频繁更新的字段不适合建立索引

（4）text，image等类型不应该建立索引，这些列的数据量大（假如text前10个字符唯一，也可以对text前10个字符建立索引）；

（5）MySQL能估计出全表扫描比使用索引更快时，不使用索引；

  (6) where条件中用不到的字段不适合建立索引，都用不到建立索引没有意义还浪费空间

 (7) 参与列计算的列不适合建索引

如：

**select \* from table where amount+100>1000，-- 这样是不走索引的，可以改造为：select \* from table where amount>1000-100。**

---------------------
作者：绕远的偶人 
原文：https://blog.csdn.net/weixin_39420024/article/details/80040549 

## 13.  怎么知道哪些索引需要优化

## 14. 大表优化

## 15. B-Tree和B+Tree

1. 由于**中间节点不存指针**，**同样大小的磁盘页可以容纳更多的节点元素**，树的高度就小。（数据量相同的情况下，B+树比B树更加“矮胖”），查找起来就更快。
2. B+树每次查找都**必须到叶子节点才能获取数据**，而B树不一定，B树可以在**非叶子节点上获取数据**。因此B+树查找的时间更稳定。
3. B+树的每一个叶子节点都有指向下一个叶子节点的指针，**方便范围查询和全表查询**：只需要从第一个叶子节点开始顺着指针一直扫描下去即可，而B树则要对树做中序遍历。

作者：yuanrw链接：https://juejin.im/post/5d5a8db1e51d4561e43a6c9c

## 16. MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？

MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，**只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。**

Innodb引擎的索引的数据结构也是B+树，**只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引**。

## 17.MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？

InnoDB是基于索引来完成行锁

select * from tab_with_index where id = 1 for update;

for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,

如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起

## 18. 聚簇索引非叶子结点放的什么（CVTE)

主键


# 索引

索引是一种用于快速找到记录的**一种数据结构。**

索引是在**存储引擎层实现**的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

索引能够轻易将查询性能提升几个数量级。

1. 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。
1. 对于中到大型的表，索引就非常有效。
1. 但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

> **索引本质：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。**

## 索引类型

### B+ Tree 索引

B-Tree 索引是大多数 MySQL 存储引擎的**默认索引类型**。

因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。

可以指定多个列作为索引列，多个索引列共同组成键。

B-Tree 索引适用于**全键值、键值范围和键前缀查找**，其中键前缀查找只适用于最左前缀查找。

除了用于查找，还可以用于排序和分组。

如果不是按照索引列的顺序进行查找，则无法使用索引。

### 哈希索引

基于哈希表实现，优点是**查找非常快**。

在 MySQL 中只有 Memory 引擎显式支持哈希索引。

InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

限制：哈希索引只包含哈希值和行指针，**而不存储字段值，所以不能使用索引中的值来避免读取行**。

不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；无法用于分组与排序；只支持精确查找，无法用于部分查找和范围查找；如果哈希冲突很多，查找速度会变得很慢。

无法用于排序和分组。

### 空间索引数据（R-Tree）

MyISAM 存储引擎支持空间索引，可以用于地理数据存储。

空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。

使用 MATCH AGAINST，而不是普通的 WHERE。

## 索引的优点

- 大大**减少了服务器需要扫描的数据量**；

- 帮助服务器避免进行排序和创建临时表；

- 将随机 I/O 变为顺序 I/O。

## 索引的缺点

- **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加

- 索引需要**占用物理空间**，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大

- 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度

## 索引优化

### 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

对于前缀长度的选取需要根据 **索引选择性** 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1 ，此时每个记录都有唯一的索引与其对应。

### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 file_id 设置为多列索引。

```sql
SELECT file_id, actor_ id FROM sakila.film_actor
WhERE actor_id = 1 OR film_id = 1;
```

### 索引列的顺序

让选择性最强的索引列放在前面，例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

### 聚簇索引

聚簇索引并不是一种索引类型，而是一种**数据存储方式**。

术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引的数据行存放在 B-Tree 的叶子页中。

**表中数据按主键B+树存放，叶子节点直接存放整条数据，**因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/clustered%20index.png)

**优点**

1. 可以把相关数据保存在一起，减少 I/O 操作；
2. 因为数据保存在 B-Tree 中，因此数据访问更快。

**缺点**

1. 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。
2. 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。
3. 更新操作代价很高，因为每个被更新的行都会移动到新的位置。
4. 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。
5. 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。

### 辅助索引

是指叶节点不包含行的全部数据，叶节点除了包含键值之外，还包含一个书签连接，通过该书签再去找相应的行数据。下图显示了

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/Secondary%20Index.png)

InnoDB存储引擎辅助索引获得数据的查找方式：

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/20190819220750.png)

从上图中可以看出，辅助索引叶节点存放的是主键值，获得主键值后，再从聚集索引中查找整行数据。举个例子，如果在一颗高度为3的辅助索引中查找数据，首先从辅助索引中获得主键值（3次IO），接着从高度为3的聚集索引中查找以获得整行数据（3次IO），总共需6次IO。一个表上可以存在多个辅助索引。

总结二者区别:

　　**相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。**

　　**不同的是：聚集索引叶子结点存放的是一整行的信息,而辅助索引叶子结点存放的是单个索引列信息.**

**何时使用聚集索引或非聚集索引**

下面的表总结了何时使用聚集索引或非聚集索引（很重要）：

| 动作描述           | 使用聚集索引 | 使用非聚集索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | 应           | 应             |
| 返回某范围内的数据 | 应           | 不应           |
| 一个或极少不同值   | 不应         | 不应           |
| 频繁更新的列       | 不应         | 应             |
| 外键列             | 应           | 应             |
| 主键列             | 应           | 应             |
| 频繁修改索引列     | 不应         | 应             |

### 覆盖索引

**即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。**

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

### 组合索引

 组合索引: 是指对表上的多个列组合起来做一个索引.

 组合索引好处:简单的说有两个主要原因：

- "一个顶三个"。建了一个(a,b,c)的组合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！

- **索引列越多，通过索引筛选出的数据越少**。有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是组合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知 

## 最左前缀原则

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件**精确匹配索引的左边连续一列或几列**，则此列就可以被用到。如下：

    select * from user where name=xx and city=xx ; ／／可以命中索引
    select * from user where name=xx ; // 可以命中索引
    select * from user where city=xx ; // 无法命中索引

## 如何为表字段添加索引

1.添加PRIMARY KEY（主键索引）

	ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 

2.添加UNIQUE(唯一索引)

	ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 

3.添加INDEX(普通索引)

	ALTER TABLE `table_name` ADD INDEX index_name ( `column` )

4.添加FULLTEXT(全文索引)

	ALTER TABLE `table_name` ADD FULLTEXT ( `column`)

5.添加多列索引

	ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )

## 正确使用索引

```mysql
#1. 范围查询(>、>=、<、<=、!= 、between...and)
    #1. = 等号
    select count(*) from userinfo where id = 1000 -- 执行索引,索引效率高
    
    #2. > >= < <= between...and 区间查询
    select count(*) from userinfo where id <100; -- 执行索引,区间范围越小,索引效率越高
    
    select count(*) from userinfo where id >100; -- 执行索引,区间范围越大,索引效率越低
    
    select count(*) from userinfo where id between 10 and 500000; -- 执行索引,区间范围越大,索引效率越低
    
   #3. != 不等于
   select count(*) from userinfo where id != 1000;  -- 索引范围大,索引效率低
   
   
#2.like '%xx%'
    #为 name 字段添加索引
    create index idx_name on userinfo(name);
    
    select count(*) from userinfo where name like '%xxxx%'; -- 全模糊查询,索引效率低
    select count(*) from userinfo where name like '%xxxx';   -- 以什么结尾模糊查询,索引效率低
  
    #例外: 当like使用以什么开头会索引使用率高
    select * from userinfo where name like 'xxxx%'; 

#3. or 
    select count(*) from userinfo where id = 12334 or email ='xxxx'; -- email不是索引字段,索引此查询全表扫描
    
    #例外：当or条件中有未建立索引的列才失效，以下会走索引
    select count(*) from userinfo where id = 12334 or name = 'alex3'; -- id 和 name 都为索引字段时, or条件也会执行索引

#4.使用函数
    select count(*) from userinfo where reverse(name) = '5xela'; -- name索引字段,使用函数时,索引失效
    
    #例外:索引字段对应的值可以使用函数,我们可以改为一下形式
    select count(*) from userinfo where name = reverse('5xela');

#5.类型不一致
    #如果列是字符串类型，传入条件是必须用引号引起来，不然...
    select count(*) from userinfo where name = 454;
        
    #类型一致
    select count(*) from userinfo where name = '454';

#6.order by
    #排序条件为索引，则select字段必须也是索引字段，否则无法命中  
    select email from userinfo ORDER BY name DESC; -- 无法命中索引

    select name from userinfo ORDER BY name DESC;  -- 命中索引
        
    #特别的:如果对主键排序，则还是速度很快：
    select id from userinfo order by id desc;
```

